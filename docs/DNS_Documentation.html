<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Domain Name System (DNS)</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>

  html {
    line-height: 1.5;
    font-family: Georgia, serif;
    font-size: 20px;
    color: #1a1a1a;
    background-color: #fdfdfd;
  }

  body {
    margin: 0 auto;
    max-width: 36em;
    padding-left: 50px;
    padding-right: 50px;
    padding-top: 50px;
    padding-bottom: 50px;
    hyphens: auto;
    word-wrap: break-word;
    text-rendering: optimizeLegibility;
    font-kerning: normal;
  }

  @media (max-width: 600px) {
    body {
      font-size: 0.9em;
      padding: 1em;
    }
  }

  @media print {
    body {
      background-color: transparent;
      color: black;
      font-size: 12pt;
    }
    p, h2, h3 {
      orphans: 3;
      widows: 3;
    }
    h2, h3, h4 {
      page-break-after: avoid;
    }
  }

  p {
    margin: 1em 0;
  }

  a {
    color: #1a1a1a;
  }

  a:visited {
    color: #1a1a1a;
  }

  img {
    max-width: 100%;
  }

  h1, h2, h3, h4, h5, h6 {
    margin-top: 1.4em;
  }

  h5, h6 {
    font-size: 1em;
    font-style: italic;
  }

  h6 {
    font-weight: normal;
  }

  ol, ul {
    padding-left: 1.7em;
    margin-top: 1em;
  }

  li>ol, li>ul {
    margin-top: 0;
  }

  blockquote {
    margin: 1em 0 1em 1.7em;
    padding-left: 1em;
    border-left: 2px solid #e6e6e6;
    color: #606060;
  }

  code {
    font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
    font-size: 85%;
    margin: 0;
  }

  pre {
    margin: 1em 0;
    overflow: auto;
    border: 3px solid black;
    background-color: lightgray;
    display: inline-block;
  }

  pre code {
    padding: 0;
    overflow: visible;
  }

  .sourceCode {
    background-color: transparent;
    overflow: visible;
  }

  hr {
    background-color: #1a1a1a;
    border: none;
    height: 1px;
    margin: 1em 0;
  }

  table {
    margin: 1em 0;
    border-collapse: collapse;
    width: 100%;
    overflow-x: auto;
    display: block;
    font-variant-numeric: lining-nums tabular-nums;
  }

  table caption {
    margin-bottom: 0.75em;
  }

  tbody {
    margin-top: 0.5em;
    border-top: 1px solid #1a1a1a;
    border-bottom: 1px solid #1a1a1a;
  }

  th {
    border-top: 1px solid #1a1a1a;
    padding: 0.25em 0.5em 0.25em 0.5em;
    text-align: left;
    border-bottom: 1px solid black;
  }

  td {
    border-bottom: 1px solid black;
    padding: 0.125em 0.5em 0.25em 0.5em;
  }

  header {
    margin-bottom: 4em;
    text-align: center;
  }

  #TOC li {
    list-style: none;
  }

  #TOC a:not(:hover) {
    text-decoration: none;
  }

  code {
    white-space: pre-wrap;
  }

  span.smallcaps {
    font-variant: small-caps;
  }

  span.underline {
    text-decoration: underline;
  }

  div.column {
    display: inline-block;
    vertical-align: top;
    width: 50%;
  }

  div.hanging-indent {
    margin-left: 1.5em;
    text-indent: -1.5em;
  }

  ul.task-list {
    list-style: none;
  }

  .display.math {
    display: block;
    text-align: center;
    margin: 0.5rem auto;
  }

  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Domain Name System (DNS)</h1>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of Contents</h2>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#dns-introduction"><span class="toc-section-number">2</span> DNS Introduction</a>
<ul>
<li><a href="#domain-name-space"><span class="toc-section-number">2.1</span> Domain Name Space</a></li>
<li><a href="#domain-name-cfg"><span class="toc-section-number">2.2</span> Domain Name CFG</a></li>
<li><a href="#resource-records-rrs"><span class="toc-section-number">2.3</span> Resource Records (RRs)</a></li>
<li><a href="#textual-expression-of-rrs"><span class="toc-section-number">2.4</span> Textual Expression of RRs</a></li>
<li><a href="#aliases-and-canonical-names"><span class="toc-section-number">2.5</span> Aliases and Canonical Names</a></li>
<li><a href="#queries"><span class="toc-section-number">2.6</span> Queries</a>
<ul>
<li><a href="#standard-queries"><span class="toc-section-number">2.6.1</span> Standard Queries</a></li>
<li><a href="#inverse-queries-obsolete"><span class="toc-section-number">2.6.2</span> Inverse Queries (Obsolete)</a></li>
</ul></li>
</ul></li>
<li><a href="#name-servers"><span class="toc-section-number">3</span> Name Servers</a>
<ul>
<li><a href="#how-the-database-is-divided-into-zones"><span class="toc-section-number">3.1</span> How the Database is Divided into Zones</a></li>
<li><a href="#technical-considerations"><span class="toc-section-number">3.2</span> Technical Considerations</a></li>
<li><a href="#name-server-internals"><span class="toc-section-number">3.3</span> Name Server Internals</a>
<ul>
<li><a href="#queries-and-responses"><span class="toc-section-number">3.3.1</span> Queries and Responses</a></li>
<li><a href="#name-server-algorithm"><span class="toc-section-number">3.3.2</span> Name Server Algorithm</a></li>
<li><a href="#wildcards"><span class="toc-section-number">3.3.3</span> Wildcards</a></li>
<li><a href="#negative-response-caching"><span class="toc-section-number">3.3.4</span> Negative Response Caching</a>
<ul>
<li><a href="#name-error-nxdomain"><span class="toc-section-number">3.3.4.1</span> Name Error (NXDOMAIN)</a></li>
<li><a href="#no-data-nodata"><span class="toc-section-number">3.3.4.2</span> No Data (NODATA)</a></li>
<li><a href="#negative-answers-from-authoritative-servers"><span class="toc-section-number">3.3.4.3</span> Negative Answers from Authoritative Servers</a></li>
<li><a href="#soa-minimum-field"><span class="toc-section-number">3.3.4.4</span> SOA Minimum Field</a></li>
<li><a href="#caching-negative-answers"><span class="toc-section-number">3.3.4.5</span> Caching Negative Answers</a></li>
<li><a href="#negative-answers-from-the-cache"><span class="toc-section-number">3.3.4.6</span> Negative Answers from the Cache</a></li>
<li><a href="#other-negative-responses"><span class="toc-section-number">3.3.4.7</span> Other Negative Responses</a>
<ul>
<li><a href="#server-failure-optional"><span class="toc-section-number">3.3.4.7.1</span> Server Failure (OPTIONAL)</a></li>
<li><a href="#dead-unreachable-server-optional"><span class="toc-section-number">3.3.4.7.2</span> Dead / Unreachable Server (OPTIONAL)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#resolvers"><span class="toc-section-number">4</span> Resolvers</a></li>
<li><a href="#dns-packet-structure"><span class="toc-section-number">5</span> DNS Packet Structure</a>
<ul>
<li><a href="#header-format"><span class="toc-section-number">5.1</span> Header Format</a>
<ul>
<li><a href="#rcode-values"><span class="toc-section-number">5.1.1</span> RCODE Values</a></li>
</ul></li>
<li><a href="#question-format"><span class="toc-section-number">5.2</span> Question Format</a></li>
<li><a href="#resource-record-format"><span class="toc-section-number">5.3</span> Resource Record Format</a></li>
<li><a href="#class-values"><span class="toc-section-number">5.4</span> CLASS Values</a></li>
<li><a href="#qclass-values"><span class="toc-section-number">5.5</span> QCLASS Values</a></li>
<li><a href="#type-values"><span class="toc-section-number">5.6</span> TYPE Values</a></li>
<li><a href="#qtype-values"><span class="toc-section-number">5.7</span> QTYPE Values</a></li>
<li><a href="#message-compression"><span class="toc-section-number">5.8</span> Message Compression</a></li>
</ul></li>
<li><a href="#standard-resource-records-rdata-all-classes"><span class="toc-section-number">6</span> Standard Resource Records RDATA (All classes)</a>
<ul>
<li><a href="#cname-rdata-format-rr-type-5"><span class="toc-section-number">6.1</span> CNAME RDATA Format (RR TYPE 5)</a></li>
<li><a href="#hinfo-rdata-format-rr-type-13"><span class="toc-section-number">6.2</span> HINFO RDATA Format (RR TYPE 13)</a></li>
<li><a href="#mb-rdata-format-experimental-rr-type-7"><span class="toc-section-number">6.3</span> MB RDATA Format (EXPERIMENTAL) (RR TYPE 7)</a></li>
<li><a href="#md-rdata-format-obsolete-rr-type-3"><span class="toc-section-number">6.4</span> MD RDATA Format (OBSOLETE) (RR TYPE 3)</a></li>
<li><a href="#mf-rdata-format-obsolete-rr-type-4"><span class="toc-section-number">6.5</span> MF RDATA Format (OBSOLETE) (RR TYPE 4)</a></li>
<li><a href="#mg-rdata-format-experimental-rr-type-8"><span class="toc-section-number">6.6</span> MG RDATA Format (EXPERIMENTAL) (RR TYPE 8)</a></li>
<li><a href="#minfo-rdata-format-experimental-rr-type-14"><span class="toc-section-number">6.7</span> MINFO RDATA Format (EXPERIMENTAL) (RR TYPE 14)</a></li>
<li><a href="#mr-rdata-format-experimental-rr-type-9"><span class="toc-section-number">6.8</span> MR RDATA Format (EXPERIMENTAL) (RR TYPE 9)</a></li>
<li><a href="#mx-rdata-format-rr-type-15"><span class="toc-section-number">6.9</span> MX RDATA Format (RR TYPE 15)</a></li>
<li><a href="#null-rdata-format-experimental-rr-type-10"><span class="toc-section-number">6.10</span> NULL RDATA Format (EXPERIMENTAL) (RR TYPE 10)</a></li>
<li><a href="#ns-rdata-format-rr-type-2"><span class="toc-section-number">6.11</span> NS RDATA Format (RR TYPE 2)</a></li>
<li><a href="#ptr-rdata-format-rr-type-12"><span class="toc-section-number">6.12</span> PTR RDATA Format (RR TYPE 12)</a></li>
<li><a href="#soa-rdata-format-rr-type-6"><span class="toc-section-number">6.13</span> SOA RDATA Format (RR TYPE 6)</a></li>
<li><a href="#txt-rdata-format-rr-type-16"><span class="toc-section-number">6.14</span> TXT RDATA format (RR TYPE 16)</a></li>
<li><a href="#srv-rdata-format-rr-type-33"><span class="toc-section-number">6.15</span> SRV RDATA Format (RR TYPE 33)</a></li>
</ul></li>
<li><a href="#internet-specific-resource-records-rdata-in-class"><span class="toc-section-number">7</span> Internet Specific Resource Records RDATA (IN class)</a>
<ul>
<li><a href="#a-rdata-format-rr-type-1"><span class="toc-section-number">7.1</span> A RDATA Format (RR TYPE 1)</a></li>
<li><a href="#aaaa-rdata-format-rr-type-28"><span class="toc-section-number">7.2</span> AAAA RDATA Format (RR TYPE 28)</a></li>
<li><a href="#wks-rdata-format-rr-type-11"><span class="toc-section-number">7.3</span> WKS RDATA Format (RR TYPE 11)</a></li>
</ul></li>
<li><a href="#in-addr.arpa-domain"><span class="toc-section-number">8</span> IN-ADDR.ARPA Domain</a></li>
<li><a href="#ip6.arpa-domain"><span class="toc-section-number">9</span> IP6.ARPA Domain</a></li>
</ul>
</nav>
<blockquote>
<p><strong>TODO</strong></p>
<ul>
<li>Update to include DNSSEC values</li>
<li>Include EDNS section of packet</li>
<li>Include sections of general resolution protocol, query/response, recursive/authoritative servers</li>
<li>Include updated Negative Caching <br></li>
</ul>
</blockquote>
<h1 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This document describes the Domain Name System (DNS), including the design, server roles, algorithms, data, use cases, and on the wire message protocol that make up the DNS. The DNS design and usage is defined in a large number of different RFCs starting back in 1983, many of which have been corrected, clarified, extended, updated, or made completely obsolete by more modern RFCs. This makes understanding the current DNS specifications in its entirety quite difficult and realistically impossible for most people.</p>
<p>In order to combat this issue, and thus make any future DNS development both easier and more accurate, this document attempts to compile all the relevent DNS RFCs into one single, up to date, clear, all encompassing document. Note that in the future, depending on the size of this document, it may be split up into multiple documents for readability.</p>
<p>For a complete list of DNS related RFCs, see <a href="https://www.bind9.net/rfc">https://www.bind9.net/rfc</a>.</p>
<p>Compiled RFCs:</p>
<ul>
<li><a href="https://www.ietf.org/rfc/rfc1033.txt">RFC-1033</a></li>
<li>(<em>WIP</em>) <a href="https://www.ietf.org/rfc/rfc1034.txt">RFC-1034</a></li>
<li>(<em>WIP</em>) <a href="https://www.ietf.org/rfc/rfc1035.txt">RFC-1035</a></li>
<li><a href="https://www.ietf.org/rfc/rfc2308.txt">RFC-2308</a></li>
<li><a href="https://www.ietf.org/rfc/rfc3425.txt">RFC-3425</a></li>
<li>(<em>TODO</em>) <a href="https://www.ietf.org/rfc/rfc4033.txt">RFC-4033</a></li>
</ul>
<p>The following RFCs are only relevent to DNS management operations, or are better described in other RFCs, and thus do not affect DNS behavior itself:</p>
<ul>
<li><a href="https://www.ietf.org/rfc/rfc881.txt">RFC-881</a></li>
<li><a href="https://www.ietf.org/rfc/rfc897.txt">RFC-897</a></li>
<li><a href="https://www.ietf.org/rfc/rfc921.txt">RFC-921</a></li>
<li><a href="https://www.ietf.org/rfc/rfc1032.txt">RFC-1032</a></li>
</ul>
<p>This document and its source, as well as a DNS library written in Rust which uses this documentation as a source of truth, is hosted on <a href="https://github.com/willfleetw/rusty_dns">https://github.com/willfleetw/rusty_dns</a>.</p>
<p><br></p>
<h1 data-number="2" id="dns-introduction"><span class="header-section-number">2</span> DNS Introduction</h1>
<p>The DNS should be thought of as a distributed, hierarchical, somewhat limited database potentially capable of storing almost any type of data. Every piece of data in the DNS is mapped to a domain name, a class, and a type.</p>
<p>The DNS has three major components:</p>
<ul>
<li><p>The DOMAIN NAME SPACE and RESOURCE RECORDS, which are specifications for a tree structured name space and data associated with the names. Conceptually, each node and leaf of the domain name space tree names a set of information, and query operations are attempts to extract specific types of information from a particular set. A query names the domain name of interest and describes the type of resource information that is desired. For example, the Internet uses some of its domain names to identify hosts; queries for address resources return Internet host addresses.</p></li>
<li><p>NAME SERVERS are server programs which hold information about the domain tree’s structure and set information. A name server may cache structure or set information about any part of the domain tree, but in general a particular name server has complete information about a subset of the domain space, and pointers to other name servers that can be used to lead to information from any part of the domain tree. Name servers know the parts of the domain tree for which they have complete information; a name server is said to be an AUTHORITY for these parts of the name space. Authoritative information is organized into units called ZONEs, and these zones can be automatically distributed to the name servers which provide redundant service for the data in a zone.</p></li>
<li><p>RESOLVERS are programs that extract information from name servers in response to client requests. Resolvers must be able to access at least one name server and use that name server’s information to answer a query directly, or pursue the query using referrals to other name servers. A resolver will typically be a system routine that is directly accessible to user programs; hence no protocol is necessary between the resolver and the user program.</p></li>
</ul>
<p><br></p>
<h2 data-number="2.1" id="domain-name-space"><span class="header-section-number">2.1</span> Domain Name Space</h2>
<pre><code>                             . (ROOT)
                             |
                             |
         +---------------------+------------------+
         |                     |                  |
     MIL                   EDU                ARPA
         |                     |                  |
         |                     |                  |
 +-----+-----+               |     +------+-----+-----+
 |     |     |               |     |      |           |
 BRL  NOSC  DARPA             |  IN-ADDR  SRI-NIC     ACC
                             |
 +--------+------------------+---------------+--------+
 |        |                  |               |        |
 UCI      MIT                 |              UDEL     YALE
         |                 ISI
         |                  |
     +---+---+              |
     |       |              |
     LCS  ACHILLES  +--+-----+-----+--------+
     |             |  |     |     |        |
     XX            A  C   VAXA  VENERA Mockapetris</code></pre>
<p>The domain name space is a tree structure. Each node and leaf on the tree corresponds to a resource set (which may be empty). The domain system makes no distinctions between the uses of the interior nodes and leaves, and the term “node” refers to both.</p>
<p>Each node has a label, which is zero to 63 octets in length. Sibling nodes may not have the same label, although the same label can be used for nodes which are not siblings. One label is reserved, and that is the null (i.e., zero length) label used for the root.</p>
<p>The domain name of a node is the list of the labels on the path from the node to the root of the tree. By convention, the labels that compose a domain name are printed or read left to right, from the most specific (lowest, farthest from the root) to the least specific (highest, closest to the root), which each label being seperated by a “.”. The domain name of a node ends with the root label, and is often written as “.”. For example, the domain name of the “XX” node on the tree would be written as “XX.LCS.MIT.EDU.”.</p>
<p>By convention, domain names can be stored with arbitrary case, but domain name comparisons for all present domain functions are done in a case-insensitive manner. When receiving a domain name or label, you should preserve its case.</p>
<p>When a user needs to type a domain name, the length of each label is omitted and the labels are separated by dots (“.”). Since a complete domain name ends with the root label, this leads to a printed form which ends in a dot. We use this property to distinguish between:</p>
<ul>
<li><p>a character string which represents a complete domain name (often called “absolute”). For example, “poneria.ISI.EDU.”</p></li>
<li><p>a character string that represents the starting labels of a domain name which is incomplete, and should be completed by local software using knowledge of the local domain (often called “relative”). For example, “poneria” used in the ISI.EDU domain.</p></li>
</ul>
<p>Internally, programs that manipulate domain names should represent them as sequences of labels, where each label is a length octet followed by an octet string. Because all domain names end at the root, which has a null string for a label, these internal representations can use a length byte of zero to terminate a domain name.</p>
<p>To simplify implementations, the total number of octets that represent a domain name (i.e., the sum of all label octets and label lengths) is limited to 255.</p>
<p><br></p>
<h2 data-number="2.2" id="domain-name-cfg"><span class="header-section-number">2.2</span> Domain Name CFG</h2>
<pre><code>&lt;domain&gt;        ::= &lt;subdomain&gt; | &quot; &quot;

&lt;subdomain&gt;     ::= &lt;label&gt; | &lt;subdomain&gt; &quot;.&quot; &lt;label&gt;

&lt;label&gt;         ::= &lt;letter&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]

&lt;ldh-str&gt;       ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;

&lt;let-dig-hyp&gt;   ::= &lt;let-dig&gt; | &quot;-&quot;

&lt;let-dig&gt;       ::= &lt;letter&gt; | &lt;digit&gt;

&lt;letter&gt;        ::= a single upper or lower case alphabetic character

&lt;digit&gt;         ::= any one of the ten digits 0 through 9</code></pre>
<p>Note that while upper and lower case letters are allowed in domain names, no significance is attached to the case. That is, two names with the same spelling but different case are to be treated as if identical.</p>
<p>The labels must follow the rules for ARPANET host names. They must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen. There are also some restrictions on the length. Labels must be 63 characters or less. (This means first two bits of all labels are always 0).</p>
<p><br></p>
<h2 data-number="2.3" id="resource-records-rrs"><span class="header-section-number">2.3</span> Resource Records (RRs)</h2>
<p>A domain name identifies a node. Each node has a set of resource information, which may be empty. The set of resource information associated with a particular name is composed of separate resource records (RRs). The order of RRs in a set is not significant, and need not be preserved by name servers, resolvers, or other parts of the DNS.</p>
<p>When we talk about a specific RR, we assume it has the following:</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OWNER</td>
<td>The domain name where the RR is found</td>
</tr>
<tr class="even">
<td>TYPE</td>
<td>An encoded 16 bit value that specifies the type of the resource in this resource record. Types refer to abstract resources</td>
</tr>
<tr class="odd">
<td>CLASS</td>
<td>An encoded 16 bit value which identifies a protocol family or instance of a protocol</td>
</tr>
<tr class="even">
<td>TTL</td>
<td>The time to live of the RR. This field is a 32 bit integer in units of seconds, an is primarily used by resolvers when they cache RRs. The TTL describes how long a RR can be cached before it should be discarded</td>
</tr>
<tr class="odd">
<td>RDATA</td>
<td>The type and sometimes class dependent data which describes the resource</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="2.4" id="textual-expression-of-rrs"><span class="header-section-number">2.4</span> Textual Expression of RRs</h2>
<p>RRs are represented in binary form in the packets of the DNS protocol, and are usually represented in highly encoded form when stored in a name server or resolver.</p>
<p>The start of the line gives the owner of the RR. If a line begins with a blank, then the owner is assumed to be the same as that of the previous RR. Blank lines are often included for readability.</p>
<p>Following the owner, we list the TTL, type, and class of the RR. Class and type use the mnemonics defined above, and TTL is an integer before the type field. In order to avoid ambiguity in parsing, type and class mnemonics are disjoint, TTLs are integers, and the type mnemonic is always last. The IN class and TTL values are often omitted from examples in the interests of clarity.</p>
<p>The resource data or RDATA section of the RR are given using knowledge of the typical representation for the data.</p>
<p>For example, we might show the RRs carried in a message as:</p>
<pre><code>ISI.EDU.        MX      10 VENERA.ISI.EDU.
                MX      10 VAXA.ISI.EDU.
VENERA.ISI.EDU. A       128.9.0.32
                A       10.1.0.52
VAXA.ISI.EDU.   A       10.2.0.27
                A       128.9.0.33</code></pre>
<p>The MX RRs have an RDATA section which consists of a 16 bit number followed by a domain name. The address RRs use a standard IP address format to contain a 32 bit internet address.</p>
<p>This example shows six RRs, with two RRs at each of three domain names.</p>
<p>Similarly we might see:</p>
<pre><code>XX.LCS.MIT.EDU. IN      A       10.0.0.44
                CH      A       MIT.EDU. 2420</code></pre>
<p>This example shows two addresses for XX.LCS.MIT.EDU, each of a different class.</p>
<p><br></p>
<h2 data-number="2.5" id="aliases-and-canonical-names"><span class="header-section-number">2.5</span> Aliases and Canonical Names</h2>
<p>Many resources might have multiple names that all represent the same thing. In order to not have the same data duplicated in multiple places, DNS has the Canonical Name (CNAME) RR.</p>
<p>The CNAME RR identifies its owner name as an alias for another domain name, known as the canonical name. If a CNAME is present at a node, no other data should be present.</p>
<p>When a name server of resolver is processing a query, if it happens to encounter a CNAME it should reset the query resolution to the domain name pointed to by the CNAME RR. The one exception is when queries match the CNAME type, they are not restarted.</p>
<p>For example, suppose a name server was processing a query with for USC- ISIC.ARPA, asking for type A information, and had the following resource records:</p>
<pre><code>USC-ISIC.ARPA   IN      CNAME   C.ISI.EDU

C.ISI.EDU       IN      A       10.0.0.52</code></pre>
<p>Both of these RRs would be returned in the response to the type A query, while a type CNAME or * query should return just the CNAME.</p>
<p><br></p>
<h2 data-number="2.6" id="queries"><span class="header-section-number">2.6</span> Queries</h2>
<p>Queries are messages which may be sent to a name server to provoke a response. In the Internet, queries are carried in UDP datagrams or over TCP connections. The response by the name server either answers the question posed in the query, refers the requester to another set of name servers, or signals some error condition.</p>
<p>In general, the user does not generate queries directly, but instead makes a request to a resolver which in turn sends one or more queries to name servers and deals with the error conditions and referrals that may result. Of course, the possible questions which can be asked in a query does shape the kind of service a resolver can provide.</p>
<p>DNS queries and responses are carried in a standard message format. The message format has a header containing a number of fixed fields which are always present, and four sections which carry query parameters and RRs.</p>
<p>The most important field in the header is a four bit field called an opcode which separates different queries. Of the possible 16 values, one (standard query) is part of the official protocol, one (status query) is optional, two (inverse and completion query) are obsolete, and the rest are unassigned.</p>
<p>The four sections are:</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Question</td>
<td>Carries the query name and other query parameters</td>
</tr>
<tr class="even">
<td>Answer</td>
<td>Carries RRs which directly answer the query</td>
</tr>
<tr class="odd">
<td>Authority</td>
<td>Carries RRs which describe other authoritative servers. May optionally carry the SOA RR for the authoritative data in the answer section</td>
</tr>
<tr class="even">
<td>Additional</td>
<td>Carries RRs which may be helpful in using the RRs in the other sections</td>
</tr>
</tbody>
</table>
<p>Note that the content, but not the format, of these sections varies with header opcode.</p>
<p>The specific format of the DNS message format is described later in this documentation.</p>
<p><br></p>
<h3 data-number="2.6.1" id="standard-queries"><span class="header-section-number">2.6.1</span> Standard Queries</h3>
<p>A standard query specifies a target domain name (QNAME), query type (QTYPE), and query class (QCLASS) and asks for RRs which match. This type of query makes up such a vast majority of DNS queries that we use the term “query” to mean standard query unless otherwise specified. The QTYPE and QCLASS fields are each 16 bits long, and are a superset of defined types and classes.</p>
<p>Using the query domain name, QTYPE, and QCLASS, the name server looks for matching RRs. In addition to relevant records, the name server may return RRs that point toward a name server that has the desired information or RRs that are expected to be useful in interpreting the relevant RRs. For example, a name server that doesn’t have the requested information may know a name server that does; a name server that returns a domain name in a relevant RR may also return the RR that binds that domain name to an address.</p>
<p>For example, a mailer tying to send mail to Mockapetris@ISI.EDU might ask the resolver for mail information about ISI.EDU, resulting in a query for QNAME=ISI.EDU, QTYPE=MX, QCLASS=IN. The response’s answer section would be:</p>
<pre><code>ISI.EDU.        MX      10 VENERA.ISI.EDU.
                MX      10 VAXA.ISI.EDU.</code></pre>
<p>while the additional section might be:</p>
<pre><code>VAXA.ISI.EDU.   A       10.2.0.27
                A       128.9.0.33
VENERA.ISI.EDU. A       10.1.0.52
                A       128.9.0.32</code></pre>
<p>Because the server assumes that if the requester wants mail exchange information, it will probably want the addresses of the mail exchanges soon afterward.</p>
<p>Note that the QCLASS=* construct requires special interpretation regarding authority. Since a particular name server may not know all of the classes available in the domain system, it can never know if it is authoritative for all classes. Hence responses to QCLASS=* queries can never be authoritative.</p>
<p><br></p>
<h3 data-number="2.6.2" id="inverse-queries-obsolete"><span class="header-section-number">2.6.2</span> Inverse Queries (Obsolete)</h3>
<p>The IQUERY operation was, historically, largely unimplemented in most name server/resolver software. In addition to this widespread disuse, the problems stated below made the entire concept widely considered unwise and poorly thoughtout. Also, the widely used alternate approach of using pointer (PTR) queries and reverse-mapped records is preferable. Consequently <a href="https://www.ietf.org/rfc/rfc3425.txt">RFC-3425</a> declared it entirely obsolete. As such, any name server or resolver receiving an IQUERY should return a “Not Implemented” error.</p>
<p>As specified in <a href="https://www.ietf.org/rfc/rfc1035.txt">RFC-1035</a> (section 6.4), the IQUERY operation for DNS queries is used to look up the name(s) which are associated with the given value. The value being sought is provided in the query’s answer section and the response fills in the question section with one or more 3-tuples of type, name and class.</p>
<p>As noted in <a href="https://www.ietf.org/rfc/rfc1035.txt">RFC-1035</a>, (section 6.4.3), inverse query processing can put quite an arduous burden on a server. A server would need to perform either an exhaustive search of its database or maintain a separate database that is keyed by the values of the primary database. Both of these approaches could strain system resource use, particularly for servers that are authoritative for millions of names.</p>
<p>Response packets from these megaservers could be exceptionally large, and easily run into megabyte sizes. For example, using IQUERY to find every domain that is delegated to one of the name servers of a large ISP could return tens of thousands of 3-tuples in the question section. This could easily be used to launch denial of service attacks.</p>
<p><br></p>
<h1 data-number="3" id="name-servers"><span class="header-section-number">3</span> Name Servers</h1>
<p>Name servers are the repositories of information that make up the domain database. The database is divided up into sections called zones, which are distributed among the name servers. While name servers can have several optional functions and sources of data, the essential task of a name server is to answer queries using data in its zones. By design, name servers can answer queries in a simple manner; the response can always be generated using only local data, and either contains the answer to the question or a referral to other name servers “closer” to the desired information.</p>
<p>A given zone will be available from several name servers to insure its availability in spite of host or communication link failure. By administrative fiat, we require every zone to be available on at least two servers, and many zones have more redundancy than that.</p>
<p>A given name server will typically support one or more zones, but this gives it authoritative information about only a small section of the domain tree. It may also have some cached non-authoritative data about other parts of the tree. The name server marks its responses to queries so that the requester can tell whether the response comes from authoritative data or not.</p>
<p><br></p>
<h2 data-number="3.1" id="how-the-database-is-divided-into-zones"><span class="header-section-number">3.1</span> How the Database is Divided into Zones</h2>
<p>The domain database is divided in two ways:</p>
<ol type="1">
<li>Class</li>
<li>Zones</li>
</ol>
<p>The class partition is simple, just imagine each class as a seperate yet parallel namespace tree.</p>
<p>Within a class, “cuts” are made between any two adjacent nodes. Each group of connected nodes froms a “zone”. The zone is authoritative for all names in the connected region. Note that the “cuts” in the namespace tree may be different for different classes.</p>
<p>The name of the node closest to the root node is often used to identify the zone itself.</p>
<p>Generally, these cuts are made at points where different orginizations are willing to take ownership of a subtree, or where an orginization wants to make further internal partitions.</p>
<p><br></p>
<h2 data-number="3.2" id="technical-considerations"><span class="header-section-number">3.2</span> Technical Considerations</h2>
<p>The data that describes a zone has four major parts:</p>
<ul>
<li><p>Authoritative data for all nodes within the zone</p></li>
<li><p>Data that defines the top node of the zone (can be thought of as part of the authoritative data)</p></li>
<li><p>Data that describes delegated subzones, i.e., cuts around the bottom of the zone</p></li>
<li><p>Data that allows access to name servers for subzones (sometimes called “glue” data)</p></li>
</ul>
<p>All of this data is expressed in the form of RRs, so a zone can be completely described in terms of a set of RRs. Whole zones can be transferred between name servers by transferring the RRs, either carried in a series of messages or by FTPing a master file which is a textual representation.</p>
<p>The authoritative data for a zone is simply all of the RRs attached to all of the nodes from the top node of the zone down to leaf nodes or nodes above cuts around the bottom edge of the zone.</p>
<p>Though logically part of the authoritative data, the RRs that describe the top node of the zone are especially important to the zone’s management. These RRs are of two types:</p>
<ul>
<li><p>Name Server (NS) RRs that list, one per RR, all of the servers for the zone</p></li>
<li><p>A single SOA RR that describes zone management parameters</p></li>
</ul>
<p>The RRs that describe cuts around the bottom of the zone are NS RRs that name the servers for the subzones. Since the cuts are between nodes, these RRs are NOT part of the authoritative data of the zone, and should be exactly the same as the corresponding RRs in the top node of the subzone. Since name servers are always associated with zone boundaries, NS RRs are only found at nodes which are the top node of some zone. In the data that makes up a zone, NS RRs are found at the top node of the zone (and are authoritative) and at cuts around the bottom of the zone (where they are not authoritative), but never in between.</p>
<p>One of the goals of the zone structure is that any zone have all the data required to set up communications with the name servers for any subzones. That is, parent zones have all the information needed to access servers for their children zones. The NS RRs that name the servers for subzones are often not enough for this task since they name the servers, but do not give their addresses. In particular, if the name of the name server is itself in the subzone, we could be faced with the situation where the NS RRs tell us that in order to learn a name server’s address, we should contact the server using the address we wish to learn. To fix this problem, a zone contains “glue” RRs which are not part of the authoritative data, and are address RRs for the servers. These RRs are only necessary if the name server’s name is “below” the cut, that is, under a subzone, and are only used as part of a referral response.</p>
<p><br></p>
<h2 data-number="3.3" id="name-server-internals"><span class="header-section-number">3.3</span> Name Server Internals</h2>
<p><br></p>
<h3 data-number="3.3.1" id="queries-and-responses"><span class="header-section-number">3.3.1</span> Queries and Responses</h3>
<p>The principal activity of name servers is to answer standard queries. Both the query and its response are carried in a standard message format which is described in <a href="https://www.ietf.org/rfc/rfc1035.txt">RFC-1035</a>. The query contains a QTYPE, QCLASS, and QNAME, which describe the types and classes of desired information and the name of interest.</p>
<p>The way that the name server answers the query depends upon whether it is operating in recursive mode or not:</p>
<ul>
<li><p>The simplest mode for the server is non-recursive, since it can answer queries using only local information: the response contains an error, the answer, or a referral to some other server “closer” to the answer. All name servers must implement non-recursive queries.</p></li>
<li><p>The simplest mode for the client is recursive, since in this mode the name server acts in the role of a resolver and returns either an error or the answer, but never referrals. This service is optional in a name server, and the name server may also choose to restrict the clients which can use recursive mode.</p></li>
</ul>
<p>Recursive service is helpful in several situations:</p>
<ul>
<li><p>a relatively simple requester that lacks the ability to use anything other than a direct answer to the question.</p></li>
<li><p>a request that needs to cross protocol or other boundaries and can be sent to a server which can act as intermediary.</p></li>
<li><p>a network where we want to concentrate the cache rather than having a separate cache for each client.</p></li>
</ul>
<p>Non-recursive service is appropriate if the requester is capable of pursuing referrals and interested in information which will aid future requests.</p>
<p>The use of recursive mode is limited to cases where both the client and the name server agree to its use. The agreement is negotiated through the use of two bits in query and response messages:</p>
<ul>
<li><p>The Recursion Available (RA) bit is set or cleared by a name server in all responses. The bit is true if the name server is willing to provide recursive service for the client, regardless of whether the client requested recursive service. That is, RA signals availability rather than use.</p></li>
<li><p>The Recursion Desired (RD) bit is set or cleared by a client in all queries. This bit specifies specifies whether the requester wants recursive service for this query. Clients may request recursive service from any name server, though they should depend upon receiving it only from servers which have previously sent an RA, or servers which have agreed to provide service through private agreement or some other means outside of the DNS protocol.</p></li>
</ul>
<p>The recursive mode occurs when a query with RD set arrives at a server which is willing to provide recursive service; the client can verify that recursive mode was used by checking that both RA and RD are set in the reply. Note that the name server should never perform recursive service unless asked via RD, since this interferes with trouble shooting of name servers and their databases.</p>
<p>If recursive service is requested and available, the recursive response to a query will be one of the following:</p>
<ul>
<li><p>The answer to the query, possibly preface by one or more CNAME RRs that specify aliases encountered on the way to an answer.</p></li>
<li><p>A name error indicating that the name does not exist. This may include CNAME RRs that indicate that the original query name was an alias for a name which does not exist.</p></li>
<li><p>A temporary error indication.</p></li>
</ul>
<p>If recursive service is not requested or is not available, the non- recursive response will be one of the following:</p>
<ul>
<li><p>An authoritative name error indicating that the name does not exist.</p></li>
<li><p>A temporary error indication.</p></li>
<li><p>Some combination of:</p>
<p>RRs that answer the question, together with an indication whether the data comes from a zone or is cached.</p>
<p>A referral to name servers which have zones which are closer ancestors to the name than the server sending the reply.</p></li>
<li><p>RRs that the name server thinks will prove useful to the requester.</p></li>
</ul>
<p><br></p>
<h3 data-number="3.3.2" id="name-server-algorithm"><span class="header-section-number">3.3.2</span> Name Server Algorithm</h3>
<p>The actual algorithm used by the name server will depend on the local OS and data structures used to store RRs. The following algorithm assumes that the RRs are organized in several tree structures, one for each zone, and another for the cache:</p>
<ol type="1">
<li><p>Set or clear the value of recursion available in the response depending on whether the name server is willing to provide recursive service. If recursive service is available and requested via the RD bit in the query, go to step 5, otherwise step 2.</p></li>
<li><p>Search the available zones for the zone which is the nearest ancestor to QNAME. If such a zone is found, go to step 3, otherwise step 4.</p></li>
<li><p>Start matching down, label by label, in the zone. The matching process can terminate several ways:</p>
<ol type="a">
<li><p>If the whole of QNAME is matched, we have found the node.</p>
<p>If the data at the node is a CNAME, and QTYPE doesn’t match CNAME, copy the CNAME RR into the answer section of the response, change QNAME to the canonical name in the CNAME RR, and go back to step 1.</p>
<p>Otherwise, copy all RRs which match QTYPE into the answer section and go to step 6.</p></li>
<li><p>If a match would take us out of the authoritative data, we have a referral. This happens when we encounter a node with NS RRs marking cuts along the bottom of a zone.</p>
<p>Copy the NS RRs for the subzone into the authority section of the reply. Put whatever addresses are available into the additional section, using glue RRs if the addresses are not available from authoritative data or the cache. Go to step 4.</p></li>
<li><p>If at some label, a match is impossible (i.e., the corresponding label does not exist), look to see if a the * label exists.</p>
<p>If the “*” label does not exist, set an authoritative name error in the response and exit. Otherwise just exit.</p>
<p>If the “*” label does exist, match RRs at that node against QTYPE. If any match, copy them into the answer section, but set the owner of the RR to be QNAME or the name of the CNAME we have followed, and not the node with the “*” label. Go to step 6.</p></li>
</ol></li>
<li><p>Start matching down in the cache. If QNAME is found in the cache, copy all RRs attached to it that match QTYPE into the answer section. If there was no delegation from authoritative data, look for the best one from the cache, and put it in the authority section. Go to step 6.</p></li>
<li><p>Using the local resolver or a copy of its algorithm (see resolver section of this memo) to answer the query. Store the results, including any intermediate CNAMEs, in the answer section of the response.</p></li>
<li><p>Using local data only, attempt to add other RRs which may be useful to the additional section of the query. Exit.</p></li>
</ol>
<p><br></p>
<h3 data-number="3.3.3" id="wildcards"><span class="header-section-number">3.3.3</span> Wildcards</h3>
<p>In the previous algorithm, special treatment was given to RRs with owner names starting with the label *. Such RRs are called wildcards. Wildcard RRs can be thought of as instructions for synthesizing RRs. When the appropriate conditions are met, the name server creates RRs with an owner name equal to the query name and contents taken from the wildcard RRs.</p>
<p>This facility is most often used to create a zone which will be used to forward mail from the Internet to some other mail system. The general idea is that any name in that zone which is presented to server in a query will be assumed to exist, with certain properties, unless explicit evidence exists to the contrary. Note that the use of the term zone here, instead of domain, is intentional; such defaults do not propagate across zone boundaries, although a subzone may choose to achieve that appearance by setting up similar defaults.</p>
<p>The contents of the wildcard RRs follows the usual rules and formats for RRs. The wildcards in the zone have an owner name that controls the query names they will match. The owner name of the wildcard RRs is of the form “*.&lt;anydomain&gt;”, where &lt;anydomain&gt; is any domain name. &lt;anydomain&gt; should not contain other “*” labels, and should be in the authoritative data of the zone. The wildcards potentially apply to descendants of &lt;anydomain&gt;, but not to &lt;anydomain&gt; itself. Another way to look at this is that the “*” label always matches at least one whole label and sometimes more, but always whole labels.</p>
<p>Wildcard RRs do not apply:</p>
<ul>
<li><p>When the query is in another zone. That is, delegation cancels the wildcard defaults.</p></li>
<li><p>When the query name or a name between the wildcard domain and the query name is known to exist. For example, if a wildcard RR has an owner name of *.X, and the zone also contains RRs attached to B.X, the wildcards would apply to queries for name Z.X (presuming there is no explicit information for Z.X), but not to B.X, A.B.X, or X.</p></li>
</ul>
<p>A “*” label appearing in a query name has no special effect, but can be used to test for wildcards in an authoritative zone; such a query is the only way to get a response containing RRs with an owner name with "*" in it. The result of such a query should not be cached.</p>
<p>Note that the contents of the wildcard RRs are not modified when used to synthesize RRs.</p>
<p>To illustrate the use of wildcard RRs, suppose a large company with a large, non-IP/TCP, network wanted to create a mail gateway. If the company was called X.COM, and IP/TCP capable gateway machine was called A.X.COM, the following RRs might be entered into the COM zone:</p>
<pre><code>X.COM           MX      10      A.X.COM

*.X.COM         MX      10      A.X.COM

A.X.COM         A       1.2.3.4
A.X.COM         MX      10      A.X.COM

*.A.X.COM       MX      10      A.X.COM</code></pre>
<p>This would cause any MX query for any domain name ending in X.COM to return an MX RR pointing at A.X.COM. Two wildcard RRs are required since the effect of the wildcard at *.X.COM is inhibited in the A.X.COM subtree by the explicit data for A.X.COM. Note also that the explicit MX data at X.COM and A.X.COM is required, and that none of the RRs above would match a query name of XX.COM.</p>
<p><br></p>
<h3 data-number="3.3.4" id="negative-response-caching"><span class="header-section-number">3.3.4</span> Negative Response Caching</h3>
<p>Originally, negative response caching was an optional behaviour for recursive and authoritative name servers. However, <a href="https://www.ietf.org/rfc/rfc2308.txt">RFC-2308</a> clarified this behavior and made it mandatory.</p>
<p>The most common negative responses indicate that a particular RRset does not exist in the DNS. The first sections of this document deal with this case. Other negative responses can indicate failures of a nameserver, those are dealt with in the Other Negative Responses section.</p>
<p>A negative response is indicated by one of the following conditions:</p>
<ol type="1">
<li>Name Error (NXDOMAIN)</li>
<li>No Data (NODATA)</li>
</ol>
<p><br></p>
<h4 data-number="3.3.4.1" id="name-error-nxdomain"><span class="header-section-number">3.3.4.1</span> Name Error (NXDOMAIN)</h4>
<p>Name errors (NXDOMAIN) are indicated by the presence of “Name Error” in the RCODE field. In this case the domain referred to by the QNAME does not exist. Note: the answer section may have RRSIG and CNAME RRs and the authority section may have SOA, NSEC, and RRSIG RRs.</p>
<p>It is possible to distinguish between a referral and a NXDOMAIN response by the presense of NXDOMAIN in the RCODE regardless of the presence of NS or SOA records in the authority section.</p>
<p>NXDOMAIN responses can be categorised into four types by the contents of the authority section. These are shown below along with a referral for comparison. Fields not mentioned are not important in terms of the examples.</p>
<pre><code>NXDOMAIN RESPONSE: TYPE 1.

Header:
    RDCODE=NXDOMAIN
Query:
    AN.EXAMPLE. A
Answer:
    AN.EXAMPLE. CNAME TRIPPLE.XX.
Authority:
    XX. SOA NS1.XX. HOSTMASTER.NS1.XX. ....
    XX. NS NS1.XX.
    XX. NS NS2.XX.
Additional:
    NS1.XX. A 127.0.0.2
    NS2.XX. A 127.0.0.3

NXDOMAIN RESPONSE: TYPE 2.

Header:
    RDCODE=NXDOMAIN
Query:
    AN.EXAMPLE. A
Answer:
    AN.EXAMPLE. CNAME TRIPPLE.XX.
Authority:
    XX. SOA NS1.XX. HOSTMASTER.NS1.XX. ....
Additional:
    &lt;empty&gt;

NXDOMAIN RESPONSE: TYPE 3.

Header:
    RDCODE=NXDOMAIN
Query:
    AN.EXAMPLE. A
Answer:
    AN.EXAMPLE. CNAME TRIPPLE.XX.
Authority:
    &lt;empty&gt;
Additional:
    &lt;empty&gt;

NXDOMAIN RESPONSE: TYPE 4

Header:
    RDCODE=NXDOMAIN
Query:
    AN.EXAMPLE. A
Answer:
    AN.EXAMPLE. CNAME TRIPPLE.XX.
Authority:
    XX. NS NS1.XX.
    XX. NS NS2.XX.
Additional:
    NS1.XX. A 127.0.0.2
    NS2.XX. A 127.0.0.3

REFERRAL RESPONSE.

Header:
    RDCODE=NOERROR
Query:
    AN.EXAMPLE. A
Answer:
    AN.EXAMPLE. CNAME TRIPPLE.XX.
Authority:
    XX. NS NS1.XX.
    XX. NS NS2.XX.
Additional:
    NS1.XX. A 127.0.0.2
    NS2.XX. A 127.0.0.3</code></pre>
<p>Note, in the four examples of NXDOMAIN responses, it is known that the name “AN.EXAMPLE.” exists, and has as its value a CNAME record. The NXDOMAIN refers to “TRIPPLE.XX”, which is then known not to exist. On the other hand, in the referral example, it is shown that “AN.EXAMPLE” exists, and has a CNAME RR as its value, but nothing is known one way or the other about the existence of “TRIPPLE.XX”, other than that “NS1.XX” or “NS2.XX” can be consulted as the next step in obtaining information about it.</p>
<p>Where no CNAME records appear, the NXDOMAIN response refers to the name in the label of the RR in the question section.</p>
<p><br></p>
<h4 data-number="3.3.4.2" id="no-data-nodata"><span class="header-section-number">3.3.4.2</span> No Data (NODATA)</h4>
<p>NODATA is indicated by an answer with the RCODE set to NOERROR and no relevant answers in the answer section. The authority section will contain an SOA record, or there will be no NS records there.</p>
<p>NODATA responses have to be algorithmically determined from the response’s contents as there is no RCODE value to indicate NODATA. In some cases to determine with certainty that NODATA is the correct response it can be necessary to send another query.</p>
<p>The authority section may contain NSEC and RRSIG RRsets in addition to NS and SOA records. CNAME and RRSIG records may exist in the answer section.</p>
<p>It is possible to distinguish between a NODATA and a referral response by the presence of a SOA record in the authority section or the absence of NS records in the authority section.</p>
<p>NODATA responses can be categorised into three types by the contents of the authority section. These are shown below along with a referral for comparison. Fields not mentioned are not important in terms of the examples.</p>
<pre><code>NODATA RESPONSE: TYPE 1.

Header:
    RDCODE=NOERROR
Query:
    ANOTHER.EXAMPLE. A
Answer:
    &lt;empty&gt;
Authority:
    EXAMPLE. SOA NS1.XX. HOSTMASTER.NS1.XX. ....
    EXAMPLE. NS NS1.XX.
    EXAMPLE. NS NS2.XX.
Additional:
    NS1.XX. A 127.0.0.2
    NS2.XX. A 127.0.0.3

NO DATA RESPONSE: TYPE 2.

Header:
    RDCODE=NOERROR
Query:
    ANOTHER.EXAMPLE. A
Answer:
    &lt;empty&gt;
Authority:
    EXAMPLE. SOA NS1.XX. HOSTMASTER.NS1.XX. ....
Additional:
    &lt;empty&gt;

NO DATA RESPONSE: TYPE 3.

Header:
    RDCODE=NOERROR
Query:
    ANOTHER.EXAMPLE. A
Answer:
    &lt;empty&gt;
Authority:
    &lt;empty&gt;
Additional:
    &lt;empty&gt;

REFERRAL RESPONSE.

Header:
    RDCODE=NOERROR
Query:
    ANOTHER.EXAMPLE. A
Answer:
    &lt;empty&gt;
Authority:
    EXAMPLE. NS NS1.XX.
    EXAMPLE. NS NS2.XX.
Additional:
    NS1.XX. A 127.0.0.2
    NS2.XX. A 127.0.0.3</code></pre>
<p>These examples, unlike the NXDOMAIN examples above, have no CNAME records, however they could, in just the same way that the NXDOMAIN examples did, in which case it would be the value of the last CNAME (the QNAME) for which NODATA would be concluded.</p>
<p><br></p>
<h4 data-number="3.3.4.3" id="negative-answers-from-authoritative-servers"><span class="header-section-number">3.3.4.3</span> Negative Answers from Authoritative Servers</h4>
<p>Name servers authoritative for a zone MUST include the SOA record of the zone in the authority section of the response when reporting an NXDOMAIN or indicating that no data of the requested type exists. This is required so that the response may be cached. The TTL of this record is set from the minimum of the MINIMUM field of the SOA record and the TTL of the SOA itself, and indicates how long a resolver may cache the negative answer. The TTL SIG record associated with the SOA record should also be trimmed in line with the SOA’s TTL.</p>
<p>If the containing zone is signed, the SOA and appropriate NSEC and RRSIG records MUST be added.</p>
<p><br></p>
<h4 data-number="3.3.4.4" id="soa-minimum-field"><span class="header-section-number">3.3.4.4</span> SOA Minimum Field</h4>
<p>The SOA minimum field has been overloaded in the past to have three different meanings, the minimum TTL value of all RRs in a zone, the default TTL of RRs which did not contain a TTL value and the TTL of negative responses.</p>
<p>Despite being the original defined meaning, the first of these, the minimum TTL value of all RRs in a zone, has never in practice been used and is hereby deprecated.</p>
<p>The second, the default TTL of RRs which contain no explicit TTL in the master zone file, is relevant only at the primary server. After a zone transfer all RRs have explicit TTLs and it is impossible to determine whether the TTL for a record was explicitly set or derived from the default after a zone transfer. Where a server does not require RRs to include the TTL value explicitly, it should provide a mechanism, not being the value of the MINIMUM field of the SOA record, from which the missing TTL values are obtained. How this is done is implementation dependent.</p>
<p>The Master File format (see Master File section) is extended to include the following directive:</p>
<pre><code>$TTL &lt;TTL&gt; [comment]</code></pre>
<p>All resource records appearing after the directive, and which do not explicitly include a TTL value, have their TTL set to the TTL given in the $TTL directive.</p>
<p>The remaining of the current meanings, of being the TTL to be used for negative responses, is the new defined meaning of the SOA minimum field.</p>
<p><br></p>
<h4 data-number="3.3.4.5" id="caching-negative-answers"><span class="header-section-number">3.3.4.5</span> Caching Negative Answers</h4>
<p>Like normal answers negative answers have a time to live (TTL). As there is no record in the answer section to which this TTL can be applied, the TTL must be carried by another method. This is done by including the SOA record from the zone in the authority section of the reply. When the authoritative server creates this record its TTL is taken from the minimum of the SOA.MINIMUM field and SOA’s TTL. This TTL decrements in a similar manner to a normal cached answer and upon reaching zero (0) indicates the cached negative answer MUST NOT be used again.</p>
<p>A negative answer that resulted from a name error (NXDOMAIN) should be cached such that it can be retrieved and returned in response to another query for the same &lt;QNAME, QCLASS&gt; that resulted in the cached negative response.</p>
<p>A negative answer that resulted from a no data error (NODATA) should be cached such that it can be retrieved and returned in response to another query for the same &lt;QNAME, QTYPE, QCLASS&gt; that resulted in the cached negative response.</p>
<p>The NXT record, if it exists in the authority section of a negative answer received, MUST be stored such that it can be be located and returned with SOA record in the authority section, as should any SIG records in the authority section. For NXDOMAIN answers there is no “necessary” obvious relationship between the NXT records and the QNAME. The NXT record MUST have the same owner name as the query name for NODATA responses.</p>
<p>Negative responses without SOA records SHOULD NOT be cached as there is no way to prevent the negative responses looping forever between a pair of servers even with a short TTL.</p>
<p>Despite the DNS forming a tree of servers, with various mis- configurations it is possible to form a loop in the query graph, e.g. two servers listing each other as forwarders, various lame server configurations. Without a TTL count down a cache negative response when received by the next server would have its TTL reset. This negative indication could then live forever circulating between the servers involved.</p>
<p>As with caching positive responses it is sensible for a resolver to limit for how long it will cache a negative response as the protocol supports caching for up to 68 years. Such a limit should not be greater than that applied to positive answers and preferably be tunable. Values of one to three hours have been found to work well and would make sensible a default. Values exceeding one day have been found to be problematic.</p>
<p><br></p>
<h4 data-number="3.3.4.6" id="negative-answers-from-the-cache"><span class="header-section-number">3.3.4.6</span> Negative Answers from the Cache</h4>
<p>When a server, in answering a query, encounters a cached negative response it MUST add the cached SOA record to the authority section of the response with the TTL decremented by the amount of time it was stored in the cache. This allows the NXDOMAIN / NODATA response to time out correctly.</p>
<p>If a NXT record was cached along with SOA record it MUST be added to the authority section. If a SIG record was cached along with a NXT record it SHOULD be added to the authority section.</p>
<p>As with all answers coming from the cache, negative answers SHOULD have an implicit referral built into the answer. This enables the resolver to locate an authoritative source. An implicit referral is characterised by NS records in the authority section referring the resolver towards a authoritative source. NXDOMAIN types 1 and 4 responses contain implicit referrals as does NODATA type 1 response.</p>
<p><br></p>
<h4 data-number="3.3.4.7" id="other-negative-responses"><span class="header-section-number">3.3.4.7</span> Other Negative Responses</h4>
<p>Caching of other negative responses is not covered by any existing RFC. There is no way to indicate a desired TTL in these responses. Care needs to be taken to ensure that there are not forwarding loops.</p>
<p><br></p>
<h5 data-number="3.3.4.7.1" id="server-failure-optional"><span class="header-section-number">3.3.4.7.1</span> Server Failure (OPTIONAL)</h5>
<p>Server failures fall into two major classes. The first is where a server can determine that it has been misconfigured for a zone. This may be where it has been listed as a server, but not configured to be a server for the zone, or where it has been configured to be a server for the zone, but cannot obtain the zone data for some reason. This can occur either because the zone file does not exist or contains errors, or because another server from which the zone should have been available either did not respond or was unable or unwilling to supply the zone.</p>
<p>The second class is where the server needs to obtain an answer from elsewhere, but is unable to do so, due to network failures, other servers that don’t reply, or return server failure errors, or similar.</p>
<p>In either case a resolver MAY cache a server failure response. If it does so it MUST NOT cache it for longer than five (5) minutes, and it MUST be cached against the specific query tuple &lt;query name, type, class, server IP address&gt;.</p>
<p><br></p>
<h5 data-number="3.3.4.7.2" id="dead-unreachable-server-optional"><span class="header-section-number">3.3.4.7.2</span> Dead / Unreachable Server (OPTIONAL)</h5>
<p>Dead / Unreachable servers are servers that fail to respond in any way to a query or where the transport layer has provided an indication that the server does not exist or is unreachable. A server may be deemed to be dead or unreachable if it has not responded to an outstanding query within 120 seconds.</p>
<p>Examples of transport layer indications are:</p>
<ul>
<li>ICMP error messages indicating host, net or port unreachable.</li>
<li>TCP resets</li>
<li>IP stack error messages providing similar indications to those above.</li>
</ul>
<p>A server MAY cache a dead server indication. If it does so it MUST NOT be deemed dead for longer than five (5) minutes. The indication MUST be stored against query tuple &lt;query name, type, class, server IP address&gt; unless there was a transport layer indication that the server does not exist, in which case it applies to all queries to that specific IP address.</p>
<h1 data-number="4" id="resolvers"><span class="header-section-number">4</span> Resolvers</h1>
<p><br></p>
<h1 data-number="5" id="dns-packet-structure"><span class="header-section-number">5</span> DNS Packet Structure</h1>
<pre><code>+---------------------+
|        Header       |
+---------------------+
|       Question      | the question for the name server
+---------------------+
|        Answer       | RRs answering the question
+---------------------+
|      Authority      | RRs pointing toward an authority
+---------------------+
|      Additional     | RRs holding additional information
+---------------------+</code></pre>
<p><br></p>
<h2 data-number="5.1" id="header-format"><span class="header-section-number">5.1</span> Header Format</h2>
<pre><code>                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   OPCODE  |AA|TC|RD|RA|   Z    |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QDCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ANCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    NSCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ARCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID</td>
<td>A 16 bit identifier assigned by the program that generates any kind of query. This identifier is copied the corresponding reply and can be used by the requester to match up replies to outstanding queries</td>
</tr>
<tr class="even">
<td>QR</td>
<td>A one bit field that specifies whether this message is a query (0), or a response (1)</td>
</tr>
<tr class="odd">
<td>OPCODE</td>
<td>A four bit field that specifies kind of query in this message. This value is set by the originator of a query and copied into the response.<br>The values are:<br>0 | A standard query (QUERY)<br>1 | An inverse query (IQUERY) (Obsolete, see <a href="https://www.ietf.org/rfc/rfc3425.txt">RFC-3425</a>)<br>2 | A server status request (STATUS)<br>3-15 | Reserved for future use</td>
</tr>
<tr class="even">
<td>AA</td>
<td>Authoritative Answer - this bit is valid in responses, and specifies that the responding name server is an authority for the domain name in question section.<br><br>Note that the contents of the answer section may have multiple owner names because of aliases. The AA bit corresponds to the name which matches the query name, or the first owner name in the answer section</td>
</tr>
<tr class="odd">
<td>TC</td>
<td>Truncation - specifies that this message was truncated due to length greater than that permitted on the transmission channel</td>
</tr>
<tr class="even">
<td>RD</td>
<td>Recursion Desired - this bit may be set in a query and is copied into the response. If RD is set, it directs the name server to pursue the query recursively. Recursive query support is optional</td>
</tr>
<tr class="odd">
<td>RA</td>
<td>Recursion Available - this bit is set or cleared in a response, and denotes whether recursive query support is available in the name server</td>
</tr>
<tr class="even">
<td>Z</td>
<td>Reserved for future use. Must be zero in all queries and responses</td>
</tr>
<tr class="odd">
<td>RCODE</td>
<td>Response code - this 4 bit field is set as part of responses to denote result.</td>
</tr>
<tr class="even">
<td>QDCOUNT</td>
<td>An unsigned 16 bit integer specifying the number of entries in the question section</td>
</tr>
<tr class="odd">
<td>ANCOUNT</td>
<td>An unsigned 16 bit integer specifying the number of resource records in the answer section</td>
</tr>
<tr class="even">
<td>NSCOUNT</td>
<td>An unsigned 16 bit integer specifying the number of name server resource records in the authority records section</td>
</tr>
<tr class="odd">
<td>ARCOUNT</td>
<td>An unsigned 16 bit integer specifying the number of resource records in the additional records section</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 data-number="5.1.1" id="rcode-values"><span class="header-section-number">5.1.1</span> RCODE Values</h3>
<p>RCODE values are a 4 bit field set as part of responses. Each value has a specific meaning depending on the type of query, the QNAME, and what resource records were returned.</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 20%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>RCODE</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>NOERROR</td>
<td>The query was successfull, and the QNAME exists but not necessarily the requested resource records.</td>
</tr>
<tr class="even">
<td>1</td>
<td>FORMERR</td>
<td>The query was malformed, and thus rejected.</td>
</tr>
<tr class="odd">
<td>2</td>
<td>SERVFAIL</td>
<td>This has 2 meanings. The first meaning is that the name server failed to correctly respond to this query due to some issue. This can happen for a number of reasons, such as timeouts during recursion, or some exception was encountered. The other meaning is that the name server failed to validate the DNSSEC signed zone, thus the zone is considered BOGUS.</td>
</tr>
<tr class="even">
<td>3</td>
<td>NXDOMAIN/NAMERROR</td>
<td>This response means that the domain name in the query does not exist. NOTE: This DOES NOT mean the resource record queried for doesn’t exist, but specifically that the domain name itself doesn’t exist. The only caveat to this is if there was a CNAME chain. This changes the meaning to instead imply that the resulting canonical name does not exist.</td>
</tr>
<tr class="odd">
<td>4</td>
<td>NOTIMPLEMENTED</td>
<td>The name server does not support the requested kind of query.</td>
</tr>
<tr class="even">
<td>5</td>
<td>REFUSED</td>
<td>The name server refuses to perform the specified operation for policy reasons. For eample, a name server may not wish to provide the information to the particular requestor, or may not wish to perform an operation for a particular piece of data.</td>
</tr>
<tr class="odd">
<td>6 - 15</td>
<td>RESERVED</td>
<td>Reserved for future use.</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.2" id="question-format"><span class="header-section-number">5.2</span> Question Format</h2>
<pre><code>                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                                               |
/                     QNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     QTYPE                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     QCLASS                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>QNAME</td>
<td>A domain name represented as a sequence of labels, where each label consists of a length octet followed by that number of octets. The domain name terminates with the zero length octet for the null label of the root. Note that this field may be an odd number of octets; no padding is used</td>
</tr>
<tr class="even">
<td>QTYPE</td>
<td>A two octet code which specifies the type of the query. The values for this field include all codes valid for a TYPE field, together with some more general codes which can match more than one type of RR</td>
</tr>
<tr class="odd">
<td>QCLASS</td>
<td>A two octet code that specifies the class of the query. For example, the QCLASS field is IN for the Internet</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.3" id="resource-record-format"><span class="header-section-number">5.3</span> Resource Record Format</h2>
<p>The answer, authority, and additional sections all share the same format: a variable number of resource records, where the number of records is specified in the corresponding count field in the header. Each resource record has the following format:</p>
<pre><code>                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                                               |
/                                               /
/                      NAME                     /
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      TYPE                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     CLASS                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      TTL                      |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                   RDLENGTH                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
/                     RDATA                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NAME</td>
<td>A &lt;domain-name&gt; to which this resource record pertains</td>
</tr>
<tr class="even">
<td>TYPE</td>
<td>Two octets containing one of the RR type codes. This field specifies the meaning of the data in the RDATA field</td>
</tr>
<tr class="odd">
<td>CLASS</td>
<td>Two octets which specify the class of the data in the RDATA field</td>
</tr>
<tr class="even">
<td>TTL</td>
<td>A 32 bit unsigned integer that specifies the time interval (in seconds) that the resource record may be cached before it should be discarded. Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached</td>
</tr>
<tr class="odd">
<td>RDLENGTH</td>
<td>An unsigned 16 bit integer that specifies the length in octets of the RDATA field</td>
</tr>
<tr class="even">
<td>RDATA</td>
<td>A variable length string of octets that describes the resource. The format of this information varies according to the TYPE and CLASS of the resource record. For example, if the TYPE is A and the CLASS is IN, the RDATA field is a 4 octet ARPA Internet address</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.4" id="class-values"><span class="header-section-number">5.4</span> CLASS Values</h2>
<p>CLASS fields appear in resource records. The following CLASS mnemonics and values are defined:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>TYPE</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IN</td>
<td>1</td>
<td>The Internet class</td>
</tr>
<tr class="even">
<td>CS</td>
<td>2</td>
<td>The CSNET class (Obsolete - used only for examples in some obsolete RFCs)</td>
</tr>
<tr class="odd">
<td>CH</td>
<td>3</td>
<td>The CHAOS class</td>
</tr>
<tr class="even">
<td>HS</td>
<td>4</td>
<td>The HESIOD [Dyer 87] class</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.5" id="qclass-values"><span class="header-section-number">5.5</span> QCLASS Values</h2>
<p>QCLASS fields appear in the question section of a query. QCLASS values are a superset of CLASS values; every CLASS is a valid QCLASS. In addition to CLASS values, the following QCLASSes are defined:</p>
<table>
<thead>
<tr class="header">
<th>TYPE</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*</td>
<td>255</td>
<td>Any class</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.6" id="type-values"><span class="header-section-number">5.6</span> TYPE Values</h2>
<p>TYPE fields are used in resource records. Note that these types are a subset of QTYPEs.</p>
<table>
<thead>
<tr class="header">
<th>TYPE</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>1</td>
<td>An IPv4 host address</td>
</tr>
<tr class="even">
<td>NS</td>
<td>2</td>
<td>An authoritative name server</td>
</tr>
<tr class="odd">
<td>MD</td>
<td>3</td>
<td>A mail destination (Obsolete - use MX)</td>
</tr>
<tr class="even">
<td>MF</td>
<td>4</td>
<td>A mail forwarder (Obsolete - use MX)</td>
</tr>
<tr class="odd">
<td>CNAME</td>
<td>5</td>
<td>The canonical name for an alias</td>
</tr>
<tr class="even">
<td>SOA</td>
<td>6</td>
<td>Marks the start of a zone of authority</td>
</tr>
<tr class="odd">
<td>MB</td>
<td>7</td>
<td>A mailbox domain name (EXPERIMENTAL)</td>
</tr>
<tr class="even">
<td>MG</td>
<td>8</td>
<td>A mail group member (EXPERIMENTAL)</td>
</tr>
<tr class="odd">
<td>MR</td>
<td>9</td>
<td>A mail rename domain name (EXPERIMENTAL)</td>
</tr>
<tr class="even">
<td>NULL</td>
<td>10</td>
<td>A null RR (EXPERIMENTAL)</td>
</tr>
<tr class="odd">
<td>WKS</td>
<td>11</td>
<td>A well known service description</td>
</tr>
<tr class="even">
<td>PTR</td>
<td>12</td>
<td>A domain name pointer</td>
</tr>
<tr class="odd">
<td>HINFO</td>
<td>13</td>
<td>Host information</td>
</tr>
<tr class="even">
<td>MINFO</td>
<td>14</td>
<td>Mailbox or mail list information</td>
</tr>
<tr class="odd">
<td>MX</td>
<td>15</td>
<td>Mail exchange</td>
</tr>
<tr class="even">
<td>TXT</td>
<td>16</td>
<td>Text strings</td>
</tr>
<tr class="odd">
<td>AAAA</td>
<td>28</td>
<td>An IPv6 host address</td>
</tr>
<tr class="even">
<td>SRV</td>
<td>33</td>
<td>Specifies location of the servers for a specific protocol</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.7" id="qtype-values"><span class="header-section-number">5.7</span> QTYPE Values</h2>
<p>QTYPE fields appear in the question part of a query. QTYPES are a superset of TYPEs, hence all TYPEs are valid QTYPEs.<br> In addition, the following QTYPEs are defined:</p>
<table>
<thead>
<tr class="header">
<th>QTYPE</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AXFR</td>
<td>252</td>
<td>A request for a transfer of an entire zone</td>
</tr>
<tr class="even">
<td>MAILB</td>
<td>253</td>
<td>A request for mailbox-related records (MB, MG, or MR)</td>
</tr>
<tr class="odd">
<td>MAILA</td>
<td>254</td>
<td>A request for mail agent RRs (Obsolete - see MX)</td>
</tr>
<tr class="even">
<td>*</td>
<td>255</td>
<td>A request for all records</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 data-number="5.8" id="message-compression"><span class="header-section-number">5.8</span> Message Compression</h2>
<p>In order to reduce the size of messages, the domain system utilizes a compression scheme which eliminates the repetition of domain names in a message. In this scheme, an entire domain name or a list of labels at the end of a domain name is replaced with a pointer to a prior occurance of the same name.</p>
<p>The pointer takes the form of a two octet sequence:</p>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| 1  1|                OFFSET                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<p>The first two bits are ones. This allows a pointer to be distinguished from a label, since the label must begin with two zero bits because labels are restricted to 63 octets or less. (The 10 and 01 combinations are reserved for future use.) The OFFSET field specifies an offset from the start of the message (i.e., the first octet of the ID field in the domain header). A zero offset specifies the first byte of the ID field, etc.</p>
<p>The compression scheme allows a domain name in a message to be represented as either:</p>
<ul>
<li><p>a sequence of labels ending in a zero octet</p></li>
<li><p>a pointer</p></li>
<li><p>a sequence of labels ending with a pointer</p></li>
</ul>
<p>Pointers can only be used for occurances of a domain name where the format is not class specific. If this were not the case, a name server or resolver would be required to know the format of all RRs it handled. As yet, there are no such cases, but they may occur in future RDATA formats.</p>
<p>If a domain name is contained in a part of the message subject to a length field (such as the RDATA section of an RR), and compression is used, the length of the compressed name is used in the length calculation, rather than the length of the expanded name.</p>
<p>Programs are free to avoid using pointers in messages they generate, although this will reduce datagram capacity, and may cause truncation. However all programs are required to understand arriving messages that contain pointers.</p>
<p>For example, a datagram might need to use the domain names F.ISI.ARPA, FOO.F.ISI.ARPA, ARPA, and the root. Ignoring the other fields of the message, these domain names might be represented as:</p>
<pre><code>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
20 |           1           |           F           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
22 |           3           |           I           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
24 |           S           |           I           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
26 |           4           |           A           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
28 |           R           |           P           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
30 |           A           |           0           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                          ...
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
40 |           3           |           F           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
42 |           O           |           O           |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
44 | 1  1|                20                       |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                          ...
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
64 | 1  1|                26                       |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                          ...
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
92 |           0           |                       |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<p>The domain name for F.ISI.ARPA is shown at offset 20. The domain name FOO.F.ISI.ARPA is shown at offset 40; this definition uses a pointer to concatenate a label for FOO to the previously defined F.ISI.ARPA. The domain name ARPA is defined at offset 64 using a pointer to the ARPA component of the name F.ISI.ARPA at 20; note that this pointer relies on ARPA being the last label in the string at 20. The root domain name is defined by a single octet of zeros at 92; the root domain name has no labels.</p>
<p><br></p>
<h1 data-number="6" id="standard-resource-records-rdata-all-classes"><span class="header-section-number">6</span> Standard Resource Records RDATA (All classes)</h1>
<p>The following RR definitions are expected to occur, at least potentially, in all classes. In particular, NS, SOA, CNAME, and PTR will be used in all classes, and have the same format in all classes. Because their RDATA format is known, all domain names in the RDATA section of these RRs may be compressed.</p>
<p>&lt;domain-name&gt; is a domain name represented as a series of labels, and terminated by a label with zero length. &lt;character-string&gt; is a single length octet followed by that number of characters. &lt;character-string&gt; is treated as binary information, and can be up to 256 characters in length (including the length octet).</p>
<p><br></p>
<h2 data-number="6.1" id="cname-rdata-format-rr-type-5"><span class="header-section-number">6.1</span> CNAME RDATA Format (RR TYPE 5)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                     CNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CNAME</td>
<td>A &lt;domain-name&gt; which specifies the canonical or primary name for the owner. The owner name is an alias</td>
</tr>
</tbody>
</table>
<p>CNAME RRs cause no additional section processing, but name servers may choose to restart the query at the canonical name in certain cases. See the description of name server logic in <a href="https://www.ietf.org/rfc/rfc1034.txt">RFC-1034</a> for details.</p>
<p><br></p>
<h2 data-number="6.2" id="hinfo-rdata-format-rr-type-13"><span class="header-section-number">6.2</span> HINFO RDATA Format (RR TYPE 13)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                      CPU                      /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                       OS                      /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CPU</td>
<td>A &lt;character-string&gt; which specifies the CPU type</td>
</tr>
<tr class="even">
<td>OS</td>
<td>A &lt;character-string&gt; which specifies the operating system type</td>
</tr>
</tbody>
</table>
<p>Standard values for CPU and OS can be found in <a href="https://www.ietf.org/rfc/rfc1010.txt">RFC-1010</a>.</p>
<p>HINFO records are used to acquire general information about a host. The main use is for protocols such as FTP that can use special procedures when talking between machines or operating systems of the same type.</p>
<p><br></p>
<h2 data-number="6.3" id="mb-rdata-format-experimental-rr-type-7"><span class="header-section-number">6.3</span> MB RDATA Format (EXPERIMENTAL) (RR TYPE 7)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   MADNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MADNAME</td>
<td>A &lt;domain-name&gt; which specifies a host which has the specified mailbox</td>
</tr>
</tbody>
</table>
<p>MB records cause additional section processing which looks up an A type RRs corresponding to MADNAME.</p>
<h2 data-number="6.4" id="md-rdata-format-obsolete-rr-type-3"><span class="header-section-number">6.4</span> MD RDATA Format (OBSOLETE) (RR TYPE 3)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   MADNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MADNAME</td>
<td>A &lt;domain-name&gt; which specifies a host which has a mail agent for the domain which should be able to deliver mail for the domain</td>
</tr>
</tbody>
</table>
<p>MD records cause additional section processing which looks up an A type record corresponding to MADNAME.</p>
<p>MD is obsolete. See the definition of MX and <a href="https://www.ietf.org/rfc/rfc974.txt">RFC-974</a> for details of the new scheme. The recommended policy for dealing with MD RRs found in a master file is to reject them, or to convert them to MX RRs with a preference of 0.</p>
<p><br></p>
<h2 data-number="6.5" id="mf-rdata-format-obsolete-rr-type-4"><span class="header-section-number">6.5</span> MF RDATA Format (OBSOLETE) (RR TYPE 4)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   MADNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MADNAME</td>
<td>A &lt;domain-name&gt; which specifies a host which has a mail agent for the domain which will accept mail for forwarding to the domain</td>
</tr>
</tbody>
</table>
<p>MF records cause additional section processing which looks up an A type record corresponding to MADNAME.</p>
<p>MF is obsolete. See the definition of MX and <a href="https://www.ietf.org/rfc/rfc974.txt">RFC-974</a> for details ofw the new scheme. The recommended policy for dealing with MD RRs found in a master file is to reject them, or to convert them to MX RRs with a preference of 10.</p>
<p><br></p>
<h2 data-number="6.6" id="mg-rdata-format-experimental-rr-type-8"><span class="header-section-number">6.6</span> MG RDATA Format (EXPERIMENTAL) (RR TYPE 8)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   MGMNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MGMNAME</td>
<td>A &lt;domain-name&gt; which specifies a mailbox which is a member of the mail group specified by the domain name</td>
</tr>
</tbody>
</table>
<p>MG records cause no additional section processing.</p>
<p><br></p>
<h2 data-number="6.7" id="minfo-rdata-format-experimental-rr-type-14"><span class="header-section-number">6.7</span> MINFO RDATA Format (EXPERIMENTAL) (RR TYPE 14)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                    RMAILBX                    /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                    EMAILBX                    /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RMAILBX</td>
<td>A &lt;domain-name&gt; which specifies a mailbox which is responsible for the mailing list or mailbox. If this domain name names the root, the owner of the MINFO RR is responsible for itself. Note that many existing mailing lists use a mailbox X-request for the RMAILBX field of mailing list X, e.g., Msgroup-request for Msgroup. This field provides a more general mechanism.</td>
</tr>
<tr class="even">
<td>EMAILBX</td>
<td>A &lt;domain-name&gt; which specifies a mailbox which is to receive error messages related to the mailing list or mailbox specified by the owner of the MINFO RR (similar to the ERRORS-TO: field which has been proposed). If this domain name names the root, errors should be returned to the sender of the message.</td>
</tr>
</tbody>
</table>
<p>MINFO records cause no additional section processing. Although these records can be associated with a simple mailbox, they are usually used with a mailing list.</p>
<p><br></p>
<h2 data-number="6.8" id="mr-rdata-format-experimental-rr-type-9"><span class="header-section-number">6.8</span> MR RDATA Format (EXPERIMENTAL) (RR TYPE 9)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   NEWNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NEWNAME</td>
<td>A &lt;domain-name&gt; which specifies a mailbox which is the proper rename of the specified mailbox</td>
</tr>
</tbody>
</table>
<p>MR records cause no additional section processing. The main use for MR is as a forwarding entry for a user who has moved to a different mailbox.</p>
<p><br></p>
<h2 data-number="6.9" id="mx-rdata-format-rr-type-15"><span class="header-section-number">6.9</span> MX RDATA Format (RR TYPE 15)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                  PREFERENCE                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   EXCHANGE                    /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PREFERENCE</td>
<td>A 16 bit integer which specifies the preference given to this RR among others at the same owner. Lower values are preferred</td>
</tr>
<tr class="even">
<td>EXCHANGE</td>
<td>A &lt;domain-name&gt; which specifies a host willing to act as a mail exchange for the owner name</td>
</tr>
</tbody>
</table>
<p>MX records cause type A and AAAA additional section processing for the host specified by EXCHANGE. The use of MX RRs is explained in detail in <a href="https://www.ietf.org/rfc/rfc974.txt">RFC-974</a>.</p>
<p><br></p>
<h2 data-number="6.10" id="null-rdata-format-experimental-rr-type-10"><span class="header-section-number">6.10</span> NULL RDATA Format (EXPERIMENTAL) (RR TYPE 10)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                  &lt;anything&gt;                   /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<p>Anything at all may be in the RDATA field so long as it is 65535 octets or less.</p>
<p>NULL records cause no additional section processing. NULL RRs are not allowed in master files. NULLs are used as placeholders in some experimental extensions of the DNS.</p>
<p><br></p>
<h2 data-number="6.11" id="ns-rdata-format-rr-type-2"><span class="header-section-number">6.11</span> NS RDATA Format (RR TYPE 2)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   NSDNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NSDNAME</td>
<td>A &lt;domain-name&gt; which specifies a host which should be authoritative for the specified class and domain</td>
</tr>
</tbody>
</table>
<p>NS records cause both the usual additional section processing to locate a type A or AAAA record, and, when used in a referral, a special search of the zone in which they reside for glue information.</p>
<p>The NS RR states that the named host should be expected to have a zone starting at owner name of the specified class. Note that the class may not indicate the protocol family which should be used to communicate with the host, although it is typically a strong hint. For example, hosts which are name servers for either Internet (IN) or Hesiod (HS) class information are normally queried using IN class protocols.</p>
<p><br></p>
<h2 data-number="6.12" id="ptr-rdata-format-rr-type-12"><span class="header-section-number">6.12</span> PTR RDATA Format (RR TYPE 12)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   PTRDNAME                    /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PTRDNAME</td>
<td>A &lt;domain-name&gt; which points to some location in the domain name space</td>
</tr>
</tbody>
</table>
<p>PTR records cause no additional section processing. These RRs are used in special domains to point to some other location in the domain space. These records are simple data, and don’t imply any special processing similar to that performed by CNAME, which identifies aliases. See the description of the IN-ADDR.ARPA domain for an example.</p>
<p><br></p>
<h2 data-number="6.13" id="soa-rdata-format-rr-type-6"><span class="header-section-number">6.13</span> SOA RDATA Format (RR TYPE 6)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                     MNAME                     /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                     RNAME                     /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    SERIAL                     |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    REFRESH                    |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     RETRY                     |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    EXPIRE                     |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    MINIMUM                    |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MNAME</td>
<td>The &lt;domain-name&gt; of the name server that was the original or primary source of data for this zone</td>
</tr>
<tr class="even">
<td>RNAME</td>
<td>A &lt;domain-name&gt; which specifies the mailbox of the person responsible for this zone</td>
</tr>
<tr class="odd">
<td>SERIAL</td>
<td>The unsigned 32 bit version number of the original copy of the zone. Zone transfers preserve this value. This value wraps and should be compared using sequence space arithmetic</td>
</tr>
<tr class="even">
<td>REFRESH</td>
<td>A 32 bit time interval before the zone should be refreshed</td>
</tr>
<tr class="odd">
<td>RETRY</td>
<td>A 32 bit time interval that should elapse before a failed refresh should be retried</td>
</tr>
<tr class="even">
<td>EXPIRE</td>
<td>A 32 bit time value that specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative</td>
</tr>
<tr class="odd">
<td>MINIMUM</td>
<td>The unsigned 32 bit minimum TTL field that should be exported with any RR from this zone</td>
</tr>
</tbody>
</table>
<p>SOA records cause no additional section processing.</p>
<p>All times are in units of seconds.</p>
<p>Most of these fields are pertinent only for name server maintenance operations. However, MINIMUM is used in negative response caching. Whenever a query is made for a record or name that does not exist, an SOA record for that zone can be included in the response. In this situation the MINIMUM field is to be interpreted as the TTL for caching the non-existence of the record or domain name. For more details, see Negative Response Caching section.</p>
<p><br></p>
<h2 data-number="6.14" id="txt-rdata-format-rr-type-16"><span class="header-section-number">6.14</span> TXT RDATA format (RR TYPE 16)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                   TXT-DATA                    /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TXT-DATA</td>
<td>One or more &lt;character-string&gt;s</td>
</tr>
</tbody>
</table>
<p>TXT RRs are used to hold descriptive text. The semantics of the text depends on the domain where it is found.</p>
<p><br></p>
<h2 data-number="6.15" id="srv-rdata-format-rr-type-33"><span class="header-section-number">6.15</span> SRV RDATA Format (RR TYPE 33)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    Priority                   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                     Weight                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      Port                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
/                     Target                    /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Priority</td>
<td>As for MX, the priority of this target host. A client MUST attempt to contact the target host with the lowest-numbered priority it can reach; target hosts with the same priority SHOULD be tried in pseudorandom order</td>
</tr>
<tr class="even">
<td>Weight</td>
<td>Load balancing mechanism. When selecting a target host among the those that have the same priority, the chance of trying this one first SHOULD be proportional to its weight. Domain administrators are urged to use Weight 0 when there isn’t any load balancing to do, to make the RR easier to read for humans (less noisy)</td>
</tr>
<tr class="odd">
<td>Port</td>
<td>The port on this target host of this service. This is often as specified in Assigned Numbers but need not be</td>
</tr>
<tr class="even">
<td>Target</td>
<td>The &lt;domain-name&gt; of the target host. There MUST be one or more A records for this name. Implementors are urged, but not required, to return the A record(s) in the Additional Data section. Name compression is to be used for this field.<br><br>A Target of “.” means that the service is decidedly not available at this domain</td>
</tr>
</tbody>
</table>
<p><br>The textual representation of a SRV RR is the following:<br> _Service._Proto.Name TTL Class SRV Priority Weight Port Target</p>
<p>This means that the name for a specific service under a domain is somewhat counter-intuitive. For example, if a browser wished to retrieve the corresponding server for <code>http://www.asdf.com/</code>, then it would make a lookup of QNAME=_http._tcp.www.asdf.com., QTYPE=33, QCLASS=1. The response would look something like:<br></p>
<pre><code>_http._tcp.www.asdf.com. 600 1 SRV 1 0 443 website.asdf.com.</code></pre>
<p><br></p>
<h1 data-number="7" id="internet-specific-resource-records-rdata-in-class"><span class="header-section-number">7</span> Internet Specific Resource Records RDATA (IN class)</h1>
<h2 data-number="7.1" id="a-rdata-format-rr-type-1"><span class="header-section-number">7.1</span> A RDATA Format (RR TYPE 1)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ADDRESS                    |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ADDRESS</td>
<td>A 32 bit IPv4 address</td>
</tr>
</tbody>
</table>
<p>Hosts that have multiple IPv4 addresses will have multiple A records.</p>
<p>A records cause no additional section processing. The RDATA section of an A line in a master file is an IPv4 address expressed as four decimal numbers separated by dots without any imbedded spaces (e.g., “10.2.0.52” or “192.0.5.6”).</p>
<p><br></p>
<h2 data-number="7.2" id="aaaa-rdata-format-rr-type-28"><span class="header-section-number">7.2</span> AAAA RDATA Format (RR TYPE 28)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                                               |
|                                               |
|                                               |
|                   ADDRESS                     |
|                                               |
|                                               |
|                                               |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ADDRESS</td>
<td>A 128 bit IPv6 address in network byte order (high-order byte first)</td>
</tr>
</tbody>
</table>
<p>Hosts that have muiltiple IPv6 addresses will have multiple AAAA records</p>
<p>AAAA records cause no additional section processing. The RDATA section of an A line in a master file is an IPv6 address expressed as a standard IPv6 address (e.g., 4321:0:1:2:3:4:567:89ab).</p>
<p><br></p>
<h2 data-number="7.3" id="wks-rdata-format-rr-type-11"><span class="header-section-number">7.3</span> WKS RDATA Format (RR TYPE 11)</h2>
<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ADDRESS                    |
|                                               |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|       PROTOCOL        |                       |
+--+--+--+--+--+--+--+--+                       |
|                                               |
/                   &lt;BIT MAP&gt;                   /
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ADDRESS</td>
<td>An 32 bit Internet address</td>
</tr>
<tr class="even">
<td>PROTOCOL</td>
<td>An 8 bit IP protocol number</td>
</tr>
<tr class="odd">
<td>&lt;BIT MAP&gt;</td>
<td>A variable length bit map. The bit map must be a multiple of 8 bits long</td>
</tr>
</tbody>
</table>
<p>The WKS record is used to describe the well known services supported by a particular protocol on a particular internet address. The PROTOCOL field specifies an IP protocol number, and the bit map has one bit per port of the specified protocol. The first bit corresponds to port 0, the second to port 1, etc. If the bit map does not include a bit for a protocol of interest, that bit is assumed zero. The appropriate values and mnemonics for ports and protocols are specified in <a href="https://www.ietf.org/rfc/rfc1010.txt">RFC-1010</a>.</p>
<p>For example, if PROTOCOL=TCP (6), the 26th bit corresponds to TCP port 25 (SMTP). If this bit is set, a SMTP server should be listening on TCP port 25; if zero, SMTP service is not supported on the specified address.</p>
<p>The purpose of WKS RRs is to provide availability information for servers for TCP and UDP. If a server supports both TCP and UDP, or has multiple Internet addresses, then multiple WKS RRs are used.</p>
<p>WKS RRs cause no additional section processing.</p>
<p>In master files, both ports and protocols are expressed using mnemonics or decimal numbers.</p>
<p><br></p>
<h1 data-number="8" id="in-addr.arpa-domain"><span class="header-section-number">8</span> IN-ADDR.ARPA Domain</h1>
<p>The Internet uses a special domain to support gateway location and Internet address to host mapping. Other classes may employ a similar strategy in other domains. The intent of this domain is to provide a guaranteed method to perform host address to host name mapping, and to facilitate queries to locate all gateways on a particular network in the Internet.</p>
<p>Note that both of these services are similar to functions that could be performed by inverse queries; the difference is that this part of the domain name space is structured according to address, and hence can guarantee that the appropriate data can be located without an exhaustive search of the domain space.</p>
<p>The domain begins at IN-ADDR.ARPA and has a substructure which follows the Internet addressing structure.</p>
<p>Domain names in the IN-ADDR.ARPA domain are defined to have up to four labels in addition to the IN-ADDR.ARPA suffix. Each label represents one octet of an Internet address, and is expressed as a character string for a decimal value in the range 0-255 (with leading zeros omitted except in the case of a zero octet which is represented by a single zero).</p>
<p>Host addresses are represented by domain names that have all four labels specified. Thus data for Internet address 10.2.0.52 is located at domain name 52.0.2.10.IN-ADDR.ARPA. The reversal, though awkward to read, allows zones to be delegated which are exactly one network of address space. For example, 10.IN-ADDR.ARPA can be a zone containing data for the ARPANET, while 26.IN-ADDR.ARPA can be a separate zone for MILNET. Address nodes are used to hold pointers to primary host names in the normal domain space.</p>
<p>Network numbers correspond to some non-terminal nodes at various depths in the IN-ADDR.ARPA domain, since Internet network numbers are either 1, 2, or 3 octets. Network nodes are used to hold pointers to the primary host names of gateways attached to that network. Since a gateway is, by definition, on more than one network, it will typically have two or more network nodes which point at it. Gateways will also have host level pointers at their fully qualified addresses.</p>
<p>Both the gateway pointers at network nodes and the normal host pointers at full address nodes use the PTR RR to point back to the primary domain names of the corresponding hosts.</p>
<p>For example, the IN-ADDR.ARPA domain will contain information about the ISI gateway between net 10 and 26, an MIT gateway from net 10 to MIT’s net 18, and A<nolink>.ISI.EDU and MULTICS<nolink>.MIT.EDU. Assuming that ISI gateway has addresses 10.2.0.22 and 26.0.0.103, and a name MILNET- GW<nolink>.ISI.EDU, and the MIT gateway has addresses 10.0.0.77 and 18.10.0.4 and a name GW<nolink>.LCS.MIT.EDU, the domain database would contain:</p>
<pre><code>10.IN-ADDR.ARPA.            PTR   MILNET-GW.ISI.EDU.
10.IN-ADDR.ARPA.            PTR   GW.LCS.MIT.EDU.
18.IN-ADDR.ARPA.            PTR   GW.LCS.MIT.EDU.
26.IN-ADDR.ARPA.            PTR   MILNET-GW.ISI.EDU.
22.0.2.10.IN-ADDR.ARPA.     PTR   MILNET-GW.ISI.EDU.
103.0.0.26.IN-ADDR.ARPA.    PTR   MILNET-GW.ISI.EDU.
77.0.0.10.IN-ADDR.ARPA.     PTR   GW.LCS.MIT.EDU.
4.0.10.18.IN-ADDR.ARPA.     PTR   GW.LCS.MIT.EDU.
103.0.3.26.IN-ADDR.ARPA.    PTR   A.ISI.EDU.
6.0.0.10.IN-ADDR.ARPA.      PTR   MULTICS.MIT.EDU.</code></pre>
<p>Thus a program which wanted to locate gateways on net 10 would originate a query of the form QTYPE=PTR, QCLASS=IN, QNAME=10.IN-ADDR.ARPA. It would receive two RRs in response:</p>
<pre><code>10.IN-ADDR.ARPA.            PTR   MILNET-GW.ISI.EDU.
10.IN-ADDR.ARPA.            PTR   GW.LCS.MIT.EDU.</code></pre>
<p>The program could then originate QTYPE=A, QCLASS=IN queries for MILNET- GW<nolink>.ISI.EDU. and GW<nolink>.LCS.MIT.EDU. to discover the Internet addresses of these gateways.</p>
<p>A resolver which wanted to find the host name corresponding to Internet host address 10.0.0.6 would pursue a query of the form QTYPE=PTR, QCLASS=IN, QNAME=6.0.0.10.IN-ADDR.ARPA, and would receive:</p>
<pre><code>6.0.0.10.IN-ADDR.ARPA.      PTR   MULTICS.MIT.EDU.</code></pre>
<p>Several cautions apply to the use of these services: - Since the IN-ADDR.ARPA special domain and the normal domain for a particular host or gateway will be in different zones, the possibility exists that that the data may be inconsistent.</p>
<ul>
<li><p>Gateways will often have two names in separate domains, only one of which can be primary.</p></li>
<li><p>Systems that use the domain database to initialize their routing tables must start with enough gateway information to guarantee that they can access the appropriate name server.</p></li>
<li><p>The gateway data only reflects the existence of a gateway in a manner equivalent to the current HOSTS.TXT file. It doesn’t replace the dynamic availability information from GGP or EGP.</p></li>
</ul>
<p><br></p>
<h1 data-number="9" id="ip6.arpa-domain"><span class="header-section-number">9</span> IP6.ARPA Domain</h1>
<p>The IP6.ARPA domain provides an analogous purpose to IN-ADDR.ARPA.</p>
<p>Previously, in <a href="https://www.ietf.org/rfc/rfc1886.txt">RFC-1886</a> the domain IP6.INT was established. However, this was deprecated in <a href="https://www.ietf.org/rfc/rfc3152.txt">RFC-3152</a> in favor of IP6.ARPA. They both serve the same purpose.</p>
<p>In this domain, a resolver which wanted to find the host name corresponding to Internet host address 4321:0:1:2:3:4:567:89ab would pursue a query of the form QTYPE=PTR, QCLASS=IN, QNAME=b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA., and would receive:</p>
<pre><code>b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.  PTR   MULTICS.MIT.EDU.</code></pre>
</body>
</html>
